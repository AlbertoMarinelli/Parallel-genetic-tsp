//
// Created by alber on 14/06/2023.
//

#ifndef GENTSP_FASTFLOWTSP_H
#define GENTSP_FASTFLOWTSP_H

#include <ff/ff.hpp>
#include <ff/farm.hpp>
#include "geneticAlgorithm.h"
#include "../graph/graph.h"
#include <iostream>
#include <vector>
#include <random>
#include <optional>
#include <algorithm>
#include <unordered_set>
#include <fstream>
#include <utility>

template<typename T>
class TSPFastFlow : public GeneticAlgorithm {
private:
    std::random_device rd;
    std::mt19937 gen{rd()};
    Graph<T> &graph;
    std::vector<std::pair<double, std::vector<int>>> population;
    std::vector<std::pair<int, int>> chunks;

    struct ChunksEmitter : ff::ff_node_t<std::pair<int, int>> {
    private:
        std::vector<std::pair<int, int>> &chunks;  // Reference to a vector of pairs
        int generationsNumber; // Number of generations to emit
    public:
        explicit ChunksEmitter(std::vector<std::pair<int, int>> &chunks, int generationsNumber_)
                : chunks(chunks), generationsNumber(generationsNumber_) {}

        std::pair<int, int> *svc(std::pair<int, int> *currentGeneration) override {
            if (generationsNumber <= 0) { // If no more generations to emit
                return this->EOS; // End of stream signal
            }
            generationsNumber--;
            std::for_each(chunks.begin(), chunks.end(), [&](std::pair<int, int> &chunk) {
                this->ff_send_out(new std::pair<int, int>(chunk.first, chunk.second)); // Send each chunk to the next stage
            });
            return this->GO_ON; // Continue processing
        }
    };

    struct ChunksCollector : ff::ff_node_t<std::pair<int, int>> {
    private:
        const int chunksNumber; // Total number of chunks to be collected
        int currentChunksNumber; // Number of remaining chunks to be collected
    public:
        explicit ChunksCollector(int chunks_number) : chunksNumber(chunks_number), currentChunksNumber(chunks_number) {}

        std::pair<int, int>* svc(std::pair<int, int>* chunk) override {
            currentChunksNumber--;

            // if all the chunks have been computed, then proceed to the next stage
            if (currentChunksNumber == 0) {
                currentChunksNumber = chunksNumber;
                this->ff_send_out(chunk);
            } else {
                delete chunk; // Delete the chunk after processing
            }
            return this->GO_ON; // Continue processing next chunks
        }
    };

    struct ChromosomeGenerationWorker : ff::ff_node_t<std::pair<int, int>> {
    private:
        Graph<int> &graph; // Reference to the graph object
        std::vector<std::pair<double, std::vector<int>>> partialPopulation; // Partial population generated by this worker
        std::vector<std::pair<double, std::vector<int>>> &population; // Reference to the complete population

    public:
        ChromosomeGenerationWorker(Graph<int> &graph, std::vector<std::pair<double, std::vector<int>>> &population)
                : graph(graph), population(population) {
        }

        std::pair<int, int>* svc(std::pair<int, int>* chunk) override {
            int start = chunk->first; // Start index of the chunk to process
            int end = chunk->second; // End index of the chunk to process
            delete chunk;
            std::random_device rd;
            std::mt19937 gen(rd());

            // Create a vector with values from 0 to numVertices
            std::vector<int> sequence(graph.getNumVertices());
            std::iota(sequence.begin(), sequence.end(), 0);

            std::vector<int> shuffledSequence(sequence);

            for (int i = start; i < end; ++i) {
                std::shuffle(shuffledSequence.begin(), shuffledSequence.end(), gen);
                partialPopulation.emplace_back(0, shuffledSequence); // Add the shuffled sequence to the partial population
            }

            // Transfer values from partialPopulation to population
            int populationIndex = 0;
            for (int i = start; i < end; ++i) {
                population[i].first = partialPopulation[populationIndex].first; // Copy fitness value
                population[i].second = partialPopulation[populationIndex].second; // Copy chromosome
                populationIndex++;
            }

            this->ff_send_out(new std::pair<int, int>(start, end)); // Send the processed chunk to the next stage
            return this->GO_ON;
        }
    };

    struct ChromosomeEvaluationWorker : ff::ff_node_t<std::pair<int, int>> {
    private:
        Graph<int> &graph;
        std::mt19937 gen;
        std::vector<std::pair<double, std::vector<int>>> partialPopulation;
        std::vector<std::pair<double, std::vector<int>>> &population;

    public:
        ChromosomeEvaluationWorker(Graph<int> &graph, std::vector<std::pair<double, std::vector<int>>> &population)
                : graph(graph), population(population), gen(std::random_device()()) {
        }

        std::pair<int, int>* svc(std::pair<int, int>* chunk) override {
            int start = chunk->first;
            int end = chunk->second;
            delete chunk;

            int chromosomeSize = graph.getNumVertices();

            std::vector<double> scores(end - start + 1); // Adjust the vector size

            for (int i = start; i < end; ++i) {

                auto& individual = population[i];

                double chromosomeScoreCurrIt = 0;
                for (size_t j = 0; j < chromosomeSize - 1; ++j) {
                    chromosomeScoreCurrIt += graph.getWeight(individual.second[j], individual.second[j + 1]);
                }
                chromosomeScoreCurrIt += graph.getWeight(individual.second[0], individual.second[chromosomeSize - 1]);

                scores[i - start] = chromosomeScoreCurrIt;
            }

            // Fill the key element in the population vector with scores
            for (int i = start; i < end; ++i) {
                population[i].first = scores[i - start];
            }

            this->ff_send_out(new std::pair<int, int>(start, end));
            return this->GO_ON;
        }
    };


    struct ChromosomeCrossoverWorker : ff::ff_node_t<std::pair<int, int>> {
    private:
        std::mt19937 gen;
        std::vector<std::pair<double, std::vector<int>>> &intermediatePopulation;
        double crossoverRate;

    public:
        ChromosomeCrossoverWorker(std::vector<std::pair<double, std::vector<int>>> &intermediatePopulation, double crossoverRate)
                :intermediatePopulation(intermediatePopulation), crossoverRate(crossoverRate), gen(std::random_device()()) {
        }

        std::pair<int, int>* svc(std::pair<int, int>* chunk) override {
            int start = chunk->first;
            int end = chunk->second;
            delete chunk;

            std::uniform_real_distribution<> prob(0.0, 1.0);
            int twentyPercent = static_cast<int>(intermediatePopulation[0].second.size() * 0.2);
            std::uniform_int_distribution<> dis(0, intermediatePopulation[0].second.size() - twentyPercent-1);

            for (int i = start; i < end; i+=2) {
                if (i + 1 < end) {
                    if (prob(gen) < crossoverRate) {
                        std::vector<int> &vec1 = intermediatePopulation[i].second;
                        std::vector<int> &vec2 = intermediatePopulation[i+1].second;

                        // Choose a random index as the starting point for the cycle
                        int startIndex = dis(gen);

                        int endIndex = startIndex+twentyPercent;

                        for (int j=startIndex; j<endIndex; j++){

                            // Find the position of the number in the vector
                            auto it = std::find(vec1.begin(), vec1.end(), vec2[j]);
                            // Find the position of the number in the vector
                            auto it_2 = std::find(vec2.begin(), vec2.end(), vec1[j]);
                            // Calculate the index using the distance between it and vec1.begin()
                            int index_1 = std::distance(vec1.begin(), it);

                            // Swap the number with the index
                            std::swap(vec1[index_1], vec1[j]);

                            // Calculate the index using the distance between it and vec1.begin()
                            int index_2 = std::distance(vec2.begin(), it_2);
                            // Swap the number with the index 0
                            std::swap(vec2[index_2], vec2[j]);
                        }
                    }
                }
            }

            this->ff_send_out(new std::pair<int, int>(start, end));
            return this->GO_ON;
        }
    };


    void setupComputation(int &workersNumber, int chromosomeNumber);

    void generatePopulation(int chromosomeNumber, int numVertices, int workers);

    void evaluate(double &evaluationsAverage, int k, int workers);

    void fitness(double &evaluationsAverage);

    void selection(std::vector<std::pair<double, std::vector<int>>> &intermediatePopulation);

    void crossover(std::vector<std::pair<double, std::vector<int>>> &intermediatePopulation, double crossoverRate, int workers);

    void mutation(std::vector<std::pair<double, std::vector<int>>> &intermediatePopulation, double mutationRate);

    void printPopulation();

    void printBestSolution();

    void printBestSolution_andPath();

    void printIntermediatePopulation(std::vector<std::pair<double, std::vector<int>>> &intermediatePopulation);

public:

    explicit TSPFastFlow(Graph<T> &graph);

    void Run(
            int chromosomeNumber,
            int generationNumber,
            double mutationRate,
            double crossoverRate,
            int workers,
            int seed)

    override;
};

template<typename T>
TSPFastFlow<T>::TSPFastFlow(Graph<T> &graph): graph(graph) {}

template<typename T>
void TSPFastFlow<T>::Run(int chromosomeNumber, int generationNumber, double mutationRate, double crossoverRate,
                         int workers, int seed) {
    double evaluationsAverage = 0;
    std::vector<std::pair<double, std::vector<int>>> intermediatePopulation;

    // Resize the vector to the desired size
    population.reserve(chromosomeNumber);
    population.resize(chromosomeNumber);
    // Fill the vector with default values
    for (auto& pair : population) {
        pair = {0.0, {}};
    }

    if (seed) {
        gen.seed(seed);
    }

    //std::ofstream outputFile("bestSolution_parallel(fastFlow).txt"); // Create an output file stream

    setupComputation(workers, chromosomeNumber);
    generatePopulation(chromosomeNumber, graph.getNumVertices(), workers);
    //printPopulation();

    for (size_t generation = 1; generation <= generationNumber; generation++) {
        evaluate(evaluationsAverage, chromosomeNumber, workers);
        //printBestSolution();

        //double bestFitness = population[0].first;
        //outputFile << bestFitness << std::endl; // Write the value to the file

        fitness(evaluationsAverage);
        selection(intermediatePopulation);
        crossover(intermediatePopulation, crossoverRate, workers);
        mutation(intermediatePopulation, mutationRate);

        evaluationsAverage = 0;

        // Swap the contents of population and intermediatePopulation
        population.swap(intermediatePopulation);
    }

    //Print best solution and path for test purposes
    //evaluate(evaluationsAverage, chromosomeNumber, workers);
    //printBestSolution_andPath();
    //printBestSolution();

    //outputFile.close(); // Close the output file stream
}

template<typename T>
void TSPFastFlow<T>::setupComputation(int &workersNumber, int chromosomeNumber) {
    // Adjust the number of workers based on the available hardware concurrency
    workersNumber =
            (workersNumber < std::thread::hardware_concurrency() - 1) ? workersNumber :
            std::thread::hardware_concurrency()
            - 1;

    // Ensure that the number of workers does not exceed the number of chromosomes
    if (workersNumber > chromosomeNumber) {
        workersNumber = chromosomeNumber;
    }

    // Clear and resize the 'chunks' vector
    chunks.clear();
    chunks.resize(workersNumber);

    // Calculate the number of chromosomes each worker will generate
    int chromosomesPerWorker = chromosomeNumber / workersNumber;
    int extraChromosomes = chromosomeNumber % workersNumber;

    int index = 0;

    // Assign chromosome ranges
    std::for_each(chunks.begin(), chunks.end(), [&](std::pair<int, int> &chunk) {
        chunk.first = index*chromosomesPerWorker;
        chunk.second=chunk.first+chromosomesPerWorker;
        index += 1;
    });

    // Adjust the range of the last worker to account for extra chromosomes
    if (!chunks.empty()) {
        std::pair<int, int>& lastElement = chunks.back();
        lastElement.second += extraChromosomes; // Modify .second
    }
}

template<typename T>
void TSPFastFlow<T>::generatePopulation(int chromosomeNumber, int numVertices, int workers) {
    auto start = std::chrono::system_clock::now();

    // Create ChunksEmitter and ChunksCollector for generating chromosomes
    ChunksEmitter generateChromosomesEmitter(chunks, 1);
    ChunksCollector generateChromosomesCollector(chunks.size());

    // Create generationWorkers for chromosome generation
    std::vector<std::unique_ptr<ff::ff_node>> generationWorkers;
    for (int i = 0; i < workers; i++) {
        generationWorkers.emplace_back(new ChromosomeGenerationWorker(graph, population));
    }

    // Create the ff_Farm for chromosome generation, using the generationWorkers, emitter, and collector
    ff::ff_Farm<std::pair<int, int>> creationFarm(std::move(generationWorkers), generateChromosomesEmitter,
                                                  generateChromosomesCollector);
    creationFarm.wrap_around();

    // Run the chromosome generation farm and check for errors
    if (creationFarm.run_and_wait_end() < 0) {
        std::cerr << "Farm Generation execution interrupted!" << std::endl;
        return;
    }

    auto end = std::chrono::system_clock::now();
    std::cout << "Generation parallel time: "<< std::chrono::duration_cast<std::chrono::milliseconds>(end - start).count() << "ms" << std::endl;
}

//Evaluate population
template<typename T>
void TSPFastFlow<T>::evaluate(double &evaluationsAverage, int k, int workers) {
    auto start = std::chrono::system_clock::now();

    setupComputation(workers, population.size());

    // Create ChunksEmitter and ChunksCollector for evaluating chromosomes
    ChunksEmitter generateChromosomesEmitter(chunks, 1);
    ChunksCollector generateChromosomesCollector(chunks.size());
    std::vector<std::unique_ptr<ff::ff_node>> evaluationWorker;
    for (int i = 0; i < workers; i++) {
        evaluationWorker.emplace_back(new ChromosomeEvaluationWorker(graph, population));
    }

    // Create the ff_Farm for chromosome generation, using the generationWorkers, emitter, and collector
    ff::ff_Farm<std::pair<int, int>> creationFarm(std::move(evaluationWorker), generateChromosomesEmitter,
                                                  generateChromosomesCollector);
    creationFarm.wrap_around();

    // Run the chromosome generation farm and check for errors
    if (creationFarm.run_and_wait_end() < 0) {
        std::cerr << "farm Evaluation execution interrupted!" << std::endl;
        return;
    }

    // Sort population by key value
    auto compareByKeyValue = [](const std::pair<double, std::vector<int>> &a,
                                const std::pair<double, std::vector<int>> &b) {
        return a.first < b.first;
    };
    std::sort(population.begin(), population.end(), compareByKeyValue);

    // Calculate evaluation average on top k elements
    double totalScore = 0;
    int numElements = std::min(k, static_cast<int>(population.size()));
    for (int i = 0; i < numElements; ++i) {
        totalScore += population[i].first;
    }

    evaluationsAverage = totalScore / numElements;
    population.resize(numElements);
    auto end = std::chrono::system_clock::now();
    std::cout << "Evaluation parallel time: "<< std::chrono::duration_cast<std::chrono::milliseconds>(end - start).count() << "ms" << std::endl;
}

//Fitness function
template<typename T>
void TSPFastFlow<T>::fitness(double &evaluationsAverage) {
    auto start = std::chrono::system_clock::now();
    for (size_t i = 0; i < population.size(); ++i) {
        auto &individual = population[i];
        individual.first /= evaluationsAverage;
    }
    auto end = std::chrono::system_clock::now();
    //std::cout << "Fitness sequential time: " << std::chrono::duration_cast<std::chrono::milliseconds>(end - start).count() << "ms" << std::endl;
}

template<typename T>
void TSPFastFlow<T>::selection(std::vector<std::pair<double, std::vector<int>>> &intermediatePopulation) {
    auto start = std::chrono::system_clock::now();
    std::uniform_real_distribution<double> distribution(0.0, 1.0);

    for (auto &individual: population) {
        int numCopies = static_cast<int>(individual.first); // Get the integer part of the key

        for (int i = 0; i < numCopies; ++i) {
            intermediatePopulation.push_back(
                    {individual.first, individual.second}); // Copy the individual to intermediatePopulation
        }

        double fractionalPart = individual.first - numCopies; // Get the fractional part of the key

        if (distribution(gen) < fractionalPart) {
            intermediatePopulation.push_back(
                    {individual.first, individual.second}); // Place an additional copy based on the fractional part
        }
    }
    auto end = std::chrono::system_clock::now();
    //std::cout << "Selection sequential time: "<< std::chrono::duration_cast<std::chrono::milliseconds>(end - start).count() << "ms" << std::endl;
}

template<typename T>
void TSPFastFlow<T>::crossover(std::vector<std::pair<double, std::vector<int>>> &intermediatePopulation,
                               double crossoverRate, int workers) {
    auto start = std::chrono::system_clock::now();

    setupComputation(workers, intermediatePopulation.size());

    // Create ChunksEmitter and ChunksCollector for evaluating chromosomes
    ChunksEmitter generateChromosomesEmitter(chunks, 1);
    ChunksCollector generateChromosomesCollector(chunks.size());

    // Create generationWorkers for chromosome generation
    std::vector<std::unique_ptr<ff::ff_node>> crossoverWorker;
    for (int i = 0; i < workers; i++) {
        crossoverWorker.emplace_back(new ChromosomeCrossoverWorker(intermediatePopulation, crossoverRate));
    }

    // Create the ff_Farm for chromosome generation, using the generationWorkers, emitter, and collector
    ff::ff_Farm<std::pair<int, int>> creationFarm(std::move(crossoverWorker), generateChromosomesEmitter,
                                                  generateChromosomesCollector);
    creationFarm.wrap_around();

    // Run the chromosome generation farm and check for errors
    if (creationFarm.run_and_wait_end() < 0) {
        std::cerr << "Farm Crossover execution interrupted!" << std::endl;
        return;
    }

    auto end = std::chrono::system_clock::now();
    std::cout << "Crossover parallel (FastFlow) time: "<< std::chrono::duration_cast<std::chrono::milliseconds>(end - start).count() << "ms" << std::endl;
}

//Mutation
template<typename T>
void TSPFastFlow<T>::mutation(std::vector<std::pair<double, std::vector<int>>> &intermediatePopulation,
                              double mutationRate) {
    auto start = std::chrono::system_clock::now();
    std::uniform_real_distribution<> dis(0.0, 1.0);

    for (auto &individual: intermediatePopulation) {
        if (dis(gen) < mutationRate) {
            int size = individual.second.size();
            if (size > 1) {
                std::uniform_int_distribution<> indexDis(0, size - 1);
                int index1 = indexDis(gen);
                int index2 = indexDis(gen);

                std::swap(individual.second[index1], individual.second[index2]);
            }
        }
    }
    auto end = std::chrono::system_clock::now();
    //std::cout << "Mutation sequential time: "<< std::chrono::duration_cast<std::chrono::milliseconds>(end - start).count() << "ms" << std::endl;
}

//Print population
template<typename T>
void TSPFastFlow<T>::printPopulation() {
    for (const auto &individual: population) {
        std::cout << "Key: " << individual.first << ", Values: ";
        for (const auto &value: individual.second) {
            std::cout << value << " ";
        }
        std::cout << std::endl;
    }
}

template<typename T>
void TSPFastFlow<T>::printBestSolution() {
    std::cout << "Best solution cost: " << population[0].first << std::endl;
}

template<typename T>
void TSPFastFlow<T>::printBestSolution_andPath() {
    int chromosomeSize = graph.getNumVertices();
    for (int i = 0; i < 1 && i < population.size(); ++i) {
        const auto &individual = population[i];
        std::cout << "Chromosome " << i << ": Score = " << individual.first << ", Path = ";
        for (const auto &vertex: individual.second) {
            std::cout << vertex << " ";
        }
        std::cout << std::endl;
    }
    if (!population.empty()) {
        auto &firstIndividual = population[0];
        double chromosomeScoreCurrIt = 0;
        for (size_t j = 0; j < chromosomeSize - 1; ++j) {
            chromosomeScoreCurrIt += graph.getWeight(firstIndividual.second[j], firstIndividual.second[j + 1]);
        }
        chromosomeScoreCurrIt += graph.getWeight(firstIndividual.second[0], firstIndividual.second[chromosomeSize - 1]);
        std::cout << "Calculated cost of solution: " << chromosomeScoreCurrIt;
    }
}

//Print population
template<typename T>
void TSPFastFlow<T>::printIntermediatePopulation(std::vector<std::pair<double, std::vector<int>>> &intermediatePopulation) {
    for (const auto &individual: intermediatePopulation) {
        std::cout << "Key: " << individual.first << ", Values: ";
        for (const auto &value: individual.second) {
            std::cout << value << " ";
        }
        std::cout << std::endl;
    }
}

#endif //GENTSP_FASTFLOWTSP_H